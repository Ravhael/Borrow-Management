// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Directorate {
  id          Int       @id @default(autoincrement())
  name        String
  code        String    @unique
  description String
  email       String
  active      Boolean   @default(true)
  entitas     Entitas[]
  users       User[]
}

model Entitas {
  id            Int         @id @default(autoincrement())
  name          String
  code          String      @unique
  description   String
  // New JSON column to support multiple contact addresses per entitas
  // Default to an object with the common roles so new rows automatically include keys
  emails        Json        @default(dbgenerated("'{\"Head\":\"\",\"Finance\":\"\",\"Admin\":\"\",\"Others\":\"\"}'::jsonb"))
  isActive      Boolean     @default(true)
  directorateId Int
  directorate   Directorate @relation(fields: [directorateId], references: [id])
  users         User[]
}

model Role {
  id          String @id
  name        String
  description String
  permissions Json
  allowedMenus  Json?   @default("[]")
  users       User[]
}

model User {
  id            String       @id
  username      String       @unique
  password      String
  name          String
  email         String       @unique
  // JSON column to store user notification metadata (last-sent notifications or preferences)
  notification  Json?
  phone         String
  passwordResetToken String? @db.Text
  passwordResetExpiresAt DateTime?
  roleid        String?
  directorateid Int?
  entitasid     Int?
  isActive      Boolean      @default(true)
  IsLoggedIn    Boolean      @default(false)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  permissions   Json
  role          Role?        @relation(fields: [roleid], references: [id])
  directorate   Directorate? @relation(fields: [directorateid], references: [id])
  entitas       Entitas?     @relation(fields: [entitasid], references: [id])
  // relation back to AuditLog entries
  auditLogs     AuditLog[]
  // loans owned by this user
  loans         Loan[]
  // marketing companies created/owned by this user
  mktCompanies  MktCompany[]
  // companies where this user is set as the warehouse contact
  warehouseCompanies MktCompany[] @relation("CompanyWarehouse")
  // next-auth relations
  accounts      Account[]
  sessions      Session[]
}

model MktCompany {
  id          Int     @id @default(autoincrement())
  value       String  @unique
  label       String
  description String? // optional human-friendly description
  isActive    Boolean @default(true)
  emails      Json
  // optional owner/creator reference (User.id is a String)
  userId      String?
  user        User?   @relation(fields: [userId], references: [id])

  // optional warehouse user for this company (references User.id)
  whId        String?
  wh          User?   @relation("CompanyWarehouse", fields: [whId], references: [id])

  // mapping to loans
  loanMappings LoanMktCompany[]

  @@index([userId])
  @@index([whId])
}

// join table: many-to-many between Loan and MktCompany
model LoanMktCompany {
  loanId    String
  companyId Int

  loan      Loan       @relation(fields: [loanId], references: [id])
  mktCompany MktCompany @relation(fields: [companyId], references: [id])

  @@id([loanId, companyId])
  @@index([companyId])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String? // the subject of the event (may be null for system-wide events)
  actorId   String? // who performed the action (admin, system, etc.)
  actorName String?
  action    String
  details   String?
  ip        String?
  meta      Json?
  createdAt DateTime @default(now())

  // optional relation for convenience
  user User? @relation(fields: [userId], references: [id])
}

// NextAuth models (for Prisma adapter & DB-backed sessions)
model Account {
  id                Int     @id @default(autoincrement())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Loans table model (maps to DB table name 'Loans')
model Loan {
  id                    String    @id
  submittedAt           DateTime?
  isDraft               Boolean   @default(false)
  entitasId             String?
  userId                String?
  user                  User?     @relation(fields: [userId], references: [id])
  borrowerPhone         String?
  borrowerEmail         String?
  borrowerName          String?
  needType              String?
  needDetails           Json? // dynamic fields specific to needType (e.g. DEMO_PRODUCT, BARANG_BACKUP, LAINNYA)
  company               String[]  @default([])
  outDate               DateTime?
  useDate               DateTime?
  returnDate            DateTime?
  productDetailsText    String?
  pickupMethod          String?
  note                  String?
  approvalAgreementFlag Boolean   @default(false)
  // Simple status field for the loan lifecycle, defaulting to PENDING for new rows
  loanStatus            String    @default("PENDING")

  submitNotifications   Json?
  approvalNotifications Json?
  approvals             Json?
  reminderStatus        Json?
  warehouseStatus       Json?
  // New column to store return processing summary including optional photo/file processing results
  // Example: { status: 'Dipinjam', note: '', processedAt: '', processedBy: '', photoResults: [{ filename, url }] }
  returnStatus          Json?
  returnNotifications   Json?
  // structured return requests stored separately
  returnRequest        Json?
  // Extension request status mirrors returnStatus: { status, note, processedAt, processedBy, photoResults }
  extendStatus          Json?
  // Extension notification payloads mirror returnNotifications structure
  extendNotification    Json?
  // Stores overdue fine summary { daysOverdue, fineAmount, updatedAt }
  totalDenda            Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // mappings to marketing companies (many-to-many via LoanMktCompany join table)
  loanMappings LoanMktCompany[]

  @@map("Loans")
}



// Mail settings persisted in DB for dev convenience. Stores the smtp JSON and notes.
model MailSettings {
  id        Int      @id @default(autoincrement())
  smtp      Json
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("MailSettings")
}

// Records scheduled reminder runs for monitoring and auditing
model ReminderRun {
  id           Int      @id @default(autoincrement())
  ranAt        DateTime @default(now())
  remindersSent Int      @default(0)
  checkedLoans  Int      @default(0)
  details       Json?

  @@index([ranAt])
}

// Apps Script / Google Sheets configuration snapshot
model AppscriptConfig {
  id            Int      @id @default(autoincrement())
  spreadsheetId String
  scriptUrl     String?
  sheetName     String?
  enabled       Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("AppscriptConfig")
}
